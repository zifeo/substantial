package metatype:substantial;

interface host {
  print: func(message: string);
  eprint: func(message: string);

  record promise {
    ref-host: string
  }

  concat: func(items: list<string>) -> promise;
}

interface utils {
  record promised-result {
    ref-host: string,
    ref-guest: u32 
  }
  // top-call-output is awaited from host side
  evaluate-guest: func(calls: promised-result, top-call-output: string) -> string;

  // use case example
  concat-then-uppercase: func(items: list<string>) -> promised-result;
}

interface backend {
  type datetime = string;

  // TODO: use list<u8> repr for protoc
  record records {
    repr: string
  }

  record metadata {
    repr: string
  }

  record event {
    repr: string
  }

  enum bakend-type {
    fs,
    redis
  }

  // run related
  read-events: func(backend: bakend-type, run-id: string) -> option<records>;
  write-events: func(backend: bakend-type, run-id: string, content: records);
  read-all-metadata: func(backend: bakend-type, run-id: string) -> list<metadata>;

  append-metadata: func(backend: bakend-type, run-id: string, schedule: datetime, content: string);
  add-schedule: func(
    backend: bakend-type, queue: string, run-id: string, schedule: datetime, content: option<event>
  );

  read-schedule: func(backend: bakend-type, queue: string, run-id: string, schedule: datetime) -> option<event>;
  close-schedule: func(backend: bakend-type, queue: string, run-id: string, schedule: datetime);

  // agent related
  // next-run(backend: bakend-type, queue: string, excludes: list[string]) -> Union[Tuple[string, datetime], None]:
  // active-leases(backend: bakend-type, lease-seconds: int) -> List[string]:
  // acquire-lease(backend: bakend-type, run-id: string, lease-seconds: int) -> bool:
  // renew-lease(backend: bakend-type, run-id: string, lease-seconds: int) -> bool:
  // remove-lease(backend: bakend-type, run-id: string, lease-seconds: int) -> None:
}

world substantial {
  export backend;
  export utils;
  import host;
}
